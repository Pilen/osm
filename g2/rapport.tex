\documentclass[10pt,a4paper,danish]{article}
\usepackage[danish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{xfrac}
\usepackage[dot, autosize, outputdir="dotgraphs/"]{dot2texi}
\usepackage{tikz}
\usetikzlibrary{shapes}

\pagestyle{fancy}
\fancyhead{}
\fancyfoot{}
\rhead{\today}
\rfoot{\thepage}
\setlength\parskip{1em}
\setlength\parindent{1em}

%% Titel og forfatter
\title{}
\author{Maria Caroline Miller, 040779, twq135 \\ Søren Pilgård, 190689, vpb984}

%% Start dokumentet
\begin{document}

%% Vis titel
\maketitle
\newpage

%% Vis indholdsfortegnelse
%% \tableofcontents
%% \newpage

\section{1.a: Datastruktur for processer}
Vores processer har forskellige oplysninger, som de skal have. De skal have noget at lave aka en executable, som beskriver den opgave, som processen udfører. Derudover er det vigtigt at de har et id, som de defineres på. De har en resultatvariabel, og en programtæller. En process skal også have en definition af hvilken tilstand den er - vi var valgt at de kan være kørende, frie eller zombie. Endelig har vores process også oplysninger om en evt. forælder, evt. børn, og dens søster.

\section{1.b: Processtabel}
Ud fra datastrukturen tilføjes i process.c en tabel, der kan indeholde alle vores processer. For at sætte en øvre grænse oprettes CONFIG\_MAX\_PROCESSES i kernel/config.h. Derudover defineres en spinlock, som skal holdes låst når man manipulerer med processtabellen.

\section{1.c: Hjælpefunktioner}
Der skal laves en række hjælpefunktioner til processstyring. Disse beskrives nedenfor.

\subsection{process\_spawn}
Denne funktion opretter en ny kernetråd med en ny process. Der kaldes et interrupt, som låser cpu'en ved at sørge for at der ikke kan kaldes andre interrupts mens den arbejder. Derefter kalder den spinlock på processtabellen, så den kan arbejde i den. Der køres igennem processtabellen, indtil der findes en tom plads. Hvis tabellen er fuld løsnes spinlocken på tabellen, der åbnes op for interrupts igen, og systemet sender en fejlkode tilbage (aka pid er stadig -1).\\

Der er lavet en løsning, som sørger for at næste gang der oprettes en ny process, starter man med at kigge tabellen fra indgangen efter hvor man sidste gang oprettede en process, hvilket burde give bedre chance for hurtigt at finde en tom plads.\\

Tabellen initialiseres derefter med oplysningerne om den nye process, og der oprettes derefter en ny kernetråd med denne nye process (til dette bruges blandt andet en ny hjælpefunktion process\_launch (se sektionen om denne)). Derefter løftes spinlocken på tabellen, og interrupts bliver igen mulige. 

\subsection{process\_run}
Starter en process. Der sikres at tråden, som processen startes i, ikke allerede kører en anden process. Derefter gøres næsten det samme som i process\_spawn, bortset fra at der tilsidst ikke oprettes en ny tråd, men at processen bare sættes igang.

\subsection{process\_get\_current\_process}
Denne funktion returnerer id for den nuværende process. Der kaldes et interrupt, og id'et for processen i den nuværende tråd hentes.

\subsection{process\_finish}
Denne funktion afslutter en process, når den er færdig med at udføre sit arbejde. Det er processen selv der kalder denne funktion. Vi starter selvfølgelig med at stoppe for interrupts, og få fat i spinlocken til tabellen. Derefter henter vi id for den nuværende process (aka den som skal afsluttes).\\

Det skal undersøges om den process, der skal afsluttes har nogle børn, og hvad der skal gøres med disse. Hvis der er nogle børn, der er zombier, er de allerede færdige med deres arbejde, og kan slettes direkte, men der kan være nogle som stadig arbejder. Der er flere muligheder for hvordan man kan behandle disse børneprocesser. Den ene mulighed er at fjerne dem, da det arbejde de laver ikke længere er interessant for forældre-processen, da denne jo har valgt at afslutte sig selv. Den anden mulighed er at betragte dem som forældreløse, og dermed lade dem udføre det arbejde de er igang med. Vi har valgt den sidste løsning. Hvis man sletter en process inden den er færdig med sit arbejde, kan man risikere at man kommer til at ødelægge noget andet. Enhver opgave, der udføres i et system har jo sideeffekter, og det ville være skidt, hvis de fik systemet til at crashe.\\

Hvis processen, der skal afsluttes har en forælder, skal resultatet jo sendes videre til forældren, inden at denne process afsluttes. Vi sætter derfor denne process til at være en zombie, som bare venter på at dens forældre beslutter sig for at køre en join, og dermed modtage resultatet. \\

Hvis forælderen sover (aka venter på at dens børn bliver færdige med deres arbejde), skal den nu vækkes i sovekøen og have at vide at dens barneprocess er færdig. Og så skal spinlocken åbnes og interrupt tillades igen. Derefter afsluttes tråden med denne process.

\subsection{process\_join}
Join sætter en process til at vente på at dens barn bliver færdig med at lave sit arbejde, så den kan samle resultatet op, og bruge dette i sit videre arbejde. Oprindeligt var funktionen af typen uint32\_t. Dette er lavet om til at være af typen int, fordi Søren! \\

Der checkes på om pid overhovedet er legalt (aka eksisterer i vores processtabel) og om den nuværende kørende process er forældre til det pid, som vi prøver at joine med. Dette er fordi man kun kan joine med sine egne børn.\\

Interrupt disables, og der hentes en lås til processtabellen. Hvis barnet ikke er en zombie, er processen ikke færdig med at køre endnu, og denne process vil derfor gerne vente. Den sætter derfor sig selv i sovekøen, låser spinlocken op, og fortæller scheduleren at den gerne må hoppe til en anden tråd. Derefter venter den bare på at den får at vide at dens barn er færdig med at arbejde, hvorefter den tager spinlocken tilbage.\\

Den gemmer resultatet, og fjerner barnet fra processtabellen, da der ikke er brug den proces mere ved hjælp af en hjælpefunktion process\_clear (se sektionen om den). Låser tabellen op, og starter interrupts igen.

\subsection{process\_init}
Funktionen løber processtabellen igennem, og clearer den for al information. Den sætter altså alt til sådan som det var i starten. Denne funktion kaldes i starten til at konfigurere alting til at starte med. Der bruges ekstra-funktionen process\_clear til dette.

\subsection{process\_launch}
Sætter tråden til at afvikle det program som processen skal køre. Den henter den nuværende tråds process id ind, og sætter derefter process\_start til at køre med den nuværende process's executable. Der er selvfølgelig sørget for at tabellen er spinlocket mens der arbejdes, og der ikke kan kaldes interrupts.

\subsection{process\_clear}
For at gøre det nemmere at instantiere en ny tabel er lagt ud i en ny hjælpefil.

\section{Opgave 2: Systemkald}

\subsection{syscall\_exec(const char *filename)}
\subsection{syscall\_exit(int retval)}
\subsection{syscall\_join(int pid)}
\subsection{syscall\_read(int fhandle, void *buffer, int length)}
\subsection{syscall\_write(int fhandle, const void *buffer, int length)}

Vi har tilføjet CONFIG\_MAX\_PROCESSES til kernel/config.h
process\_join er ændret til at være int for at passe med process\_finish. Det giver mening at processer kan returnere negative værdier.
\end{document}
